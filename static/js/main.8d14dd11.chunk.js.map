{"version":3,"sources":["lib/components/ErrorBoundary.jsx","lib/FIFOStrategy.tsx","lib/Cache.tsx","lib/QuotaExceededError.ts","lib/LocalStorageCache.tsx","lib/LZCompression.tsx","lib/Events.ts","lib/useFetch.jsx","store/selectors/cancerOriginsSelector.js","store/selectors/filteredPatientsSelector.js","subscribers/redux.js","components/MyFancyLoader.jsx","components/PatientList.jsx","components/Fetch.jsx","store/actions/filterActions.js","store/reducers/filterReducer.js","store/index.js","store/reducers/patients.js","store/reducers/cancerOrigins.js","App.js","reportWebVitals.js","index.js"],"names":["ErrorBoundary","props","state","hasError","error","errorInfo","console","log","this","children","React","Component","FIFOStrategy","expiresList","length","item","i","Cache","protectedList","entry","filter","p","RegExp","test","getExpiresList","key","isProtected","map","QuotaExceededError","message","name","Error","LocalStorageCache","strategy","maximumSize","Infinity","protectedFromCleaning","Blob","Object","values","localStorage","size","get","getItem","JSON","parse","expiration","keys","el","expiresAt","value","Date","getTime","feedback","getStorageSize","setItem","idx","element","stringify","e","getKeyByExpiration","findOne","remove","set","removeItem","ex","has","forEach","k","LZCompression","content","timeout","Promise","resolve","reject","setTimeout","time","compressed","compress","timeEnd","compressedContent","decompress","Events","topic","callback","channels","push","data","ch","defaultConfig","baseUrl","authentificationHeader","compressionTimeoutDelay","UseFetch","config","configure","cache","compressor","fetchApi","url","a","options","headers","queryParams","join","fetch","response","cancerOriginSelector","cancerOrigins","filteredPatientsSelector","patients","postId","fillTopics","subscribers","dispatch","subscribe","type","entity","payload","fill","fillSubscription","MyFancyLoader","Patient","patient","PatientList","useSelector","id","Patients","useState","setData","loading","setLoading","useEffect","promisesObject","promisesKeys","promisesValues","c","publish","method","result","allSettled","jsonValuesPromises","jv","status","json","v","asyncEffect","useFetch","_limit","order","isLoading","useDispatch","FilterByCancerOrigin","changeFilter","useCallback","target","onChange","origin","title","store","createStore","combineReducers","action","window","__REDUX_DEVTOOLS_EXTENSION__","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8d14dd11.chunk.js","sourcesContent":["import React from 'react'\r\nexport class ErrorBoundary extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = { hasError: false };\r\n    }\r\n\r\n    static getDerivedStateFromError(error) {\r\n        console.log('Something is wrong')\r\n        return { hasError: true };\r\n    }\r\n\r\n    componentDidCatch(error, errorInfo) {\r\n        console.log({...error}, errorInfo)\r\n    }\r\n\r\n    render() {\r\n        if (this.state.hasError) {\r\n            return <h1>Something went wrong.</h1>;\r\n        }\r\n\r\n        return this.props.children;\r\n    }\r\n}","import { Strategy } from './Strategy'\r\n\r\n/**\r\n * Used to make operations on a collection using the First in First Out strategy\r\n */\r\nexport class FIFOStrategy implements Strategy {\r\n\r\n    /**\r\n     * Retrieve the oldest item\r\n     * @param expiresList The collection which we need to retrieve the oldest item\r\n     * @returns The oldest item\r\n     */\r\n    findOne(expiresList: string[] | number[]): string | number {\r\n        if(expiresList.length <= 0) return ''\r\n        let item = expiresList[0]\r\n        for(let i = 1; i < expiresList.length; i++){\r\n            if(expiresList[i] < item){\r\n                item = expiresList[i]\r\n            }\r\n        }\r\n        return item\r\n    }\r\n\r\n}","/**\r\n * The Cache abstract class\r\n */\r\nexport abstract class Cache {\r\n    /**\r\n     * Protected from cleaning list\r\n     */\r\n    private protectedList: any[] = []\r\n    /**\r\n     * @param protectedList The list of the protected from cleaning entries.\r\n     */\r\n    constructor(protectedList: any[]) {\r\n        this.protectedList = [...protectedList, 'expires']\r\n    }\r\n    /**\r\n     * Check the existance of an item on the cache\r\n     * @param key The key of the item that you want to check the existance on the cache\r\n     */\r\n    abstract has(key: string): boolean\r\n    /**\r\n     * Retrieve an item from the cache\r\n     * @param key The key of the item that you want to get from the cache\r\n     */\r\n    abstract get(key: string): string | null\r\n    /**\r\n     * Get when the items expire as a list\r\n     */\r\n    abstract getExpiresList(): any[]\r\n    /**\r\n     * Set an item on the cache\r\n     * @param key The key to be set on the cache\r\n     * @param value The value to be set on the cache\r\n     * @param expiresAt The timestamp when the item will be considered as an expired\r\n     */\r\n    abstract set(key: string, value: string, expiresAt: number): boolean\r\n    /**\r\n     * Remove an item from the cache using its key\r\n     * @param key The key of the item that you want to remove from the cache\r\n     */\r\n    abstract remove(key: string): boolean\r\n    /**\r\n     * Get the used cache storage size\r\n     */\r\n    abstract getStorageSize(): number\r\n    /**\r\n     * Clean all the cache\r\n     */\r\n    abstract removeAll(): void\r\n    /**\r\n     * Check if an entry is protected from cleaning\r\n     * @param entry The entry that you want to check if protected from cleaning or not\r\n     */\r\n    isProtected(entry: any) {\r\n        return this.protectedList.filter(p => new RegExp(p).test(entry)).length > 0\r\n    }\r\n    /**\r\n     * Get the non protected againt the cleaning expiring timestamps as a list\r\n     */\r\n    getNonProtectedExpiresAtList(): number[] {\r\n        return this.getExpiresList().filter(({ key }) => !this.isProtected(key)).map(({ key }) => {\r\n            return key\r\n        })\r\n    }\r\n}","/**\r\n * The implementation of the Quota exceeded exception\r\n */\r\nexport class QuotaExceededError extends Error {\r\n    /**\r\n     * Create a new Quota exceeded exception\r\n     * @param message The message of the exception\r\n     */\r\n    constructor(message: string | undefined) {\r\n        super(message)\r\n        this.name = 'QuotaExceededError'\r\n    }\r\n}","import { Cache } from './Cache'\r\nimport { QuotaExceededError } from './QuotaExceededError'\r\nimport { Strategy } from './Strategy'\r\n\r\n/**\r\n * An implementation of the Cache abstract class\r\n */\r\nexport class LocalStorageCache extends Cache {\r\n\r\n    /**\r\n     * The strategy that you want to use in the case of a cleaning\r\n     */\r\n    strategy: Strategy\r\n    /**\r\n     * The maximum size before cleaning the cache\r\n     */\r\n    maximumSize: number\r\n\r\n    /**\r\n     * \r\n     * @param strategy The strategy that you want to use in the case of a cleaning\r\n     * @param maximumSize The maximum size before cleaning the cache\r\n     * @param protectedFromCleaning The protected entries list against the cleaning\r\n     */\r\n    constructor(strategy: Strategy, maximumSize: number = Infinity, protectedFromCleaning: any[] = []) {\r\n        super(protectedFromCleaning)\r\n        this.strategy = strategy\r\n        this.maximumSize = maximumSize\r\n    }\r\n\r\n    /**\r\n     * Calculate the entire used cache size or an item size\r\n     * @param item The item that you want to calculate its size\r\n     */\r\n    getStorageSize(item: string | null = null): number {\r\n        return new Blob(Object.values(item ? item : localStorage)).size\r\n    }\r\n\r\n    /**\r\n     * Check the existance of an item on the cache by its key\r\n     * @param key The key that you want to check the existance on the cache\r\n     */\r\n    has(key: string): boolean {\r\n        return this.get(key) !== null\r\n    }\r\n    /**\r\n     * Retrieve an item from the cache by its key\r\n     * @param key The key that you want to get from the cache\r\n     */\r\n    get(key: string): string | null {\r\n        return localStorage.getItem(key)\r\n    }\r\n    /**\r\n     * Get when the cache's items will be expired as a list of object\r\n     */\r\n    getExpiresList(): any[] {\r\n        return this.get('expires') ? JSON.parse(this.get('expires') || '[]') : []\r\n    }\r\n    /**\r\n     * Get when the cache's items will be expired as a list of items\r\n     */\r\n    getExpiresAtList(): number[] {\r\n        return this.getExpiresList().map(({ key }) => {\r\n            return key\r\n        })\r\n    }\r\n    /**\r\n     * Retrieve the key of the passed expiration on the expiration timestamps list\r\n     * @param expiration The expiration that you want to retrieve the correspendant key\r\n     */\r\n    getKeyByExpiration(expiration: string | number) {\r\n        const keys = Object.keys(this.getExpiresList().filter(el => {\r\n            return el.expiresAt == expiration\r\n        }))\r\n        return keys.length <= 0 ? null : keys[0]\r\n    }\r\n    /**\r\n     * Set an item on the cache\r\n     * @param key The key of the item that you want to set\r\n     * @param value The value of the item that you want to set\r\n     * @param expiresAt The expiration timestamp of the item that you want to set\r\n     */\r\n    set(key: string, value: string, expiresAt: number): boolean {\r\n        if(!expiresAt){\r\n            expiresAt = new Date().getTime() + 1000 * 60 * 5 // by default 5 minutes, to be changed to be global\r\n        }\r\n        /**\r\n         * The feedback refers if the item is inserted successfully in the storage or not\r\n         */\r\n        let feedback = false\r\n        try {\r\n            // Check the storage and clean it if necessary.\r\n            if (this.getStorageSize(value) + this.getStorageSize() >= this.maximumSize) throw new QuotaExceededError('Quota is exceeded, try to clean the storage...')\r\n            // set the item on the localstorage            \r\n            localStorage.setItem(key, value)\r\n            const expiresList = this.getExpiresList()\r\n            // Get the index of the item if exists\r\n            const idx = expiresList.map((el, idx) => {\r\n                if(Object.keys(el)[0] === key) return idx\r\n            }).filter(el => el )[0]\r\n            // retrieve the correspending element or creating a new\r\n            let element: any = expiresList[idx || expiresList.length] || {}\r\n            // Set the expires at on the element\r\n            element[key] = expiresAt\r\n            // Create or replace the element on the expires list\r\n            expiresList[idx || expiresList.length] = element\r\n            // Update the expiresList on the localstorage\r\n            localStorage.setItem('expires', JSON.stringify(expiresList))\r\n            // The item is set successfully\r\n            feedback = true\r\n        } catch (e) {\r\n            if (e instanceof QuotaExceededError) {\r\n                // Find the oldest item non protected item\r\n                const item = this.getKeyByExpiration(this.strategy.findOne(super.getNonProtectedExpiresAtList()))\r\n                // delete this item\r\n                const isRemoved = this.remove(item || '')\r\n                // try again to set the item if the storage is more free\r\n                if (isRemoved && item)\r\n                    this.set(key, value, expiresAt)\r\n            } else {\r\n                // The item is not set\r\n                feedback = false\r\n            }\r\n        } finally {\r\n            return feedback\r\n        }\r\n    }\r\n    /**\r\n     * Remove an item from the cache by its key\r\n     * @param key The key of the item that you want to remove\r\n     */\r\n    remove(key: string): boolean {\r\n        localStorage.removeItem(key)\r\n        localStorage.setItem('expires', JSON.stringify(this.getExpiresList().filter(ex => ex.key != key)))\r\n        if (this.has(key)) return false\r\n        return true\r\n    }\r\n    /**\r\n     * Clean all the cache\r\n     */\r\n    removeAll(): void{\r\n        Object.keys(localStorage).forEach(k => this.remove(k))\r\n    }\r\n}","import { Compression } from \"./Compression\";\r\nimport { compress, decompress } from 'lz-string'\r\n\r\n/**\r\n * An implementation of the Compression interface\r\n */\r\nexport class LZCompression implements Compression {\r\n\r\n    /**\r\n     * Compress a content\r\n     * @param content The content that you want to compress\r\n     * @param timeout The timeout to bypass the compression process\r\n     * @returns A string promise that resolves the compressed content or the original content in the case of the delay\r\n     */\r\n    compress(content: string, timeout = 0): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            setTimeout(resolve, timeout, content)\r\n            console.time('compress')\r\n            const compressed = compress(content)\r\n            console.timeEnd('compress')\r\n            setTimeout(resolve, 0, compressed)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Decompress a compressed content or the content, or return the same content if not compressed\r\n     * @param compressedContent The compressed content that you want to decompress\r\n     */\r\n    decompress(compressedContent: string): string | null {\r\n        return /[\\x00-\\x1F]/.test(compressedContent) ? decompress(compressedContent) : compressedContent\r\n    }\r\n\r\n}","/**\r\n * The Events emitter class\r\n */\r\nexport class Events {\r\n\r\n    /**\r\n     * Channels for the topics and the callbacks\r\n     */\r\n    private static channels: any = {};\r\n\r\n    /**\r\n     * \r\n     * @param topic The topic that you want to subscribe or listen for the coming events\r\n     * @param callback The callback that you want to call when the current topic published\r\n     */\r\n    static subscribe(topic: string, callback: any): any {\r\n        if(this.channels[topic]){\r\n            this.channels[topic].push(callback)\r\n        }\r\n        this.channels[topic] = [callback]\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param topic The topic that you want to publish as an outcoming event\r\n     * @param data The data that you want to send when publishing this topic\r\n     */\r\n    static publish(topic: string, ...data: any): any {\r\n        if(!this.channels[topic]) return\r\n        this.channels[topic].forEach((ch: any) => {\r\n            ch(...data)\r\n        });\r\n    }\r\n\r\n}\r\n","import { useEffect, useState } from \"react\"\r\nimport { FIFOStrategy } from \"./FIFOStrategy\"\r\nimport { LocalStorageCache } from \"./LocalStorageCache\"\r\nimport { LZCompression } from \"./LZCompression\"\r\nimport { Events } from \"./Events\"\r\n\r\n/**\r\n * The default config of the useFetch\r\n */\r\nconst defaultConfig = {\r\n    baseUrl: '',\r\n    authentificationHeader: () => {\r\n        return {\r\n            'Authorization': ''\r\n        }\r\n    },\r\n    compressionTimeoutDelay: 200,\r\n    maximumSize: 2 * 1024 * 1024, // 2Mb.\r\n    protectedFromCleaning: ['profile', /^patients\\/importants/]\r\n}\r\n\r\n/**\r\n * The global UseFetch object\r\n */\r\nconst UseFetch = {\r\n    /**\r\n     * The config that has been passed\r\n     */\r\n    config: {},\r\n    /**\r\n     * Pass a configuration to the UseFetch global object\r\n     */\r\n    configure: (callback) => {\r\n        UseFetch.config = callback({ ...defaultConfig, ...UseFetch.config })\r\n    }\r\n}\r\n\r\n/**\r\n * Bootstraping the application services\r\n */\r\nconst cache = new LocalStorageCache(new FIFOStrategy(), UseFetch.config.maximumSize, UseFetch.config.protectedFromCleaning)\r\nconst compressor = new LZCompression()\r\n\r\n/**\r\n * \r\n * @param {string} url The url that you want to fetch from\r\n * @param {Object} options The options that you want to pass to the fetch api\r\n * @param {boolean} fromCache Determine if we should return from the cache or the fetch api, don't retrieve from the cache by default\r\n */\r\nconst fetchApi = async (url, options = {}, fromCache = false) => {\r\n    if (fromCache) {\r\n        return cache.get(url)\r\n    }\r\n    if (!options.headers) options.headers = UseFetch.config.authentificationHeader()\r\n    else options.headers = { ...options.headers, ...UseFetch.authentificationHeader() }\r\n    if (options.queryParams) {\r\n        url += '?' + Object.keys(options.queryParams)\r\n            .map(key => `${key}=${options.queryParams[key]}`)\r\n            .join('&')\r\n    }\r\n    const response = await fetch(UseFetch.config.baseUrl ? UseFetch.config.baseUrl + url : url, options)\r\n    return response\r\n}\r\n\r\n/**\r\n * useFetch hook\r\n * @param {CallableFunction} callback The callback function to be passed to this hook\r\n */\r\nexport const useFetch = (callback) => {\r\n    // const dispatch = useDispatch()\r\n    const [data, setData] = useState({})\r\n    const [loading, setLoading] = useState(false)\r\n    useEffect(() => {\r\n        const asyncEffect = async () => {\r\n            const promisesObject = callback(fetchApi)\r\n            const promisesKeys = Object.keys(promisesObject)\r\n            const promisesValues = Object.values(promisesObject)\r\n            const c = {}\r\n            await promisesKeys.forEach(async el => {\r\n                try {\r\n                    c[el] = compressor.decompress(await fetchApi(el, UseFetch.config, true))\r\n                    Events.publish('cache_' + el, JSON.parse(c[el]), {\r\n                        method: 'get',\r\n                        entity: el,\r\n                        payload: JSON.parse(c[el])\r\n                    })\r\n                    // dispatch({\r\n                    //     type: '@' + el + '/fill',\r\n                    //     payload: JSON.parse(c[el])\r\n                    // })\r\n                } catch (e) {\r\n                    // The cache is corrupted or empty...\r\n                }\r\n            })\r\n            setData(c)\r\n            setLoading(true)\r\n            const result = {}\r\n            const values = await Promise.allSettled(promisesValues)\r\n            const jsonValuesPromises = values.map(jv => (jv.status === 'rejected' ? Promise.resolve([]) : jv.value.json()))\r\n            const jsonValues = await Promise.allSettled(jsonValuesPromises)\r\n            jsonValues.forEach(async (v, i) => {\r\n                result[promisesKeys[i]] = v.value\r\n                cache.set(promisesKeys[i], await compressor.compress(JSON.stringify(v.value), UseFetch.config.compressionTimeoutDelay))\r\n            })\r\n            setData(result)\r\n            // Object.keys(result).forEach(k => dispatch({\r\n            //     type: '@' + k + '/fill',\r\n            //     payload: result[k]\r\n            // }))\r\n\r\n            Object.keys(result).forEach(k => Events.publish('get_' + k, result[k], {\r\n                method: 'get',\r\n                entity: k,\r\n                payload: result[k]\r\n            }))\r\n            setLoading(false)\r\n        }\r\n        asyncEffect()\r\n        return () => {\r\n            // setLoading(false)\r\n        }\r\n    }, [])\r\n    return [data, loading]\r\n}\r\n\r\nexport default UseFetch","export const cancerOriginSelector = ({ cancerOrigins }) => cancerOrigins","export const filteredPatientsSelector = ({ patients, filter }) => {\r\n    if (filter === 'all') {\r\n        return patients\r\n    }\r\n\r\n    return patients.filter(({ postId }) => (postId == filter))\r\n}","import { Events } from \"../lib/Events\";\r\n\r\nconst fillTopics = ['get_patients', 'cache_patients', 'get_cancerOrigins', 'cache_cancerOrigins']\r\n\r\nconst fill = (data, { entity }, dispatch) => {\r\n    dispatch({\r\n        type: '@' + entity + '/fill',\r\n        payload: data\r\n    })\r\n}\r\n\r\nconst fillSubscription = (topic, dispatch) => {\r\n    Events.subscribe(topic, (data, { entity }) => {\r\n        fill(data, { entity }, dispatch)\r\n    })\r\n}\r\n\r\n/**\r\n * Bootstrap the redux subscribers\r\n * @param {any} dispatch The redux useDispatch hook\r\n */\r\nexport const subscribers = (dispatch) => {\r\n    /**\r\n     * Dispatch the fetched topics\r\n     */\r\n    fillTopics.forEach(topic => fillSubscription(topic, dispatch))\r\n\r\n    // /**\r\n    //  * Dispatch the cached patients\r\n    //  */\r\n    // fillSubscription('cache_patients', dispatch)\r\n\r\n    // /**\r\n    //  * Dispatch the fetched cancer origins\r\n    //  */\r\n    // fillSubscription('get_cancerOrigins', dispatch)\r\n\r\n    // /**\r\n    //  * Dispatch the cached cancer origins\r\n    //  */\r\n    // fillSubscription('cache_cancerOrigins', dispatch)\r\n}","export const MyFancyLoader = () => {\r\n    return 'Loading...'\r\n}","import React from 'react'\r\nimport { useSelector } from \"react-redux\"\r\nimport { filteredPatientsSelector } from '../store/selectors'\r\n\r\nconst Patient = ({ patient }) => (<li>{patient.postId} - {patient.name}</li>)\r\n\r\nexport const PatientList = () => {\r\n    const patients = useSelector(filteredPatientsSelector)\r\n\r\n    return <ul>\r\n        {patients.map(p => <Patient key={p.id} patient={p} />)}\r\n    </ul>\r\n}","import React, { useEffect, useCallback } from 'react'\r\nimport { Fragment } from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux'\r\nimport { ErrorBoundary } from '../lib/components/ErrorBoundary'\r\nimport UseFetch, { useFetch } from '../lib/useFetch'\r\nimport { updateFilterAction } from '../store/actions'\r\nimport { cancerOriginSelector } from '../store/selectors'\r\nimport { subscribers } from '../subscribers/redux'\r\nimport { MyFancyLoader } from './MyFancyLoader'\r\nimport { PatientList } from './PatientList'\r\n\r\n// DSL Configuration\r\nUseFetch.configure((config) => {\r\n  config.baseUrl = 'https://jsonplaceholder.typicode.com/'\r\n  config.authentificationHeader = () => {\r\n    return {\r\n      'Authorization': localStorage.getItem('id_token')\r\n    }\r\n  }\r\n  config.compressionTimeoutDelay = 200\r\n  config.maximumSize = 2 * 1024 * 1024 // 2Mb.\r\n  config.protectedFromCleaning = ['profile', /^patients\\/importants/]\r\n  return config\r\n})\r\n\r\n// Usage on application component\r\nexport const Patients = () => {\r\n  // const dispatch = useDispatch()\r\n\r\n  const [{ patients, cancerOrigins }, isLoading] = useFetch((fetch) => {\r\n    return {\r\n      patients: fetch('comments', { queryParams: { _limit: 10 } }),\r\n      cancerOrigins: fetch('posts', { queryParams: { _limit: 2, order: 'label ASC' } })\r\n    }\r\n  })\r\n\r\n  const dispatch = useDispatch()\r\n\r\n  useEffect(() => {\r\n    console.log('redux subscribers initialized...')\r\n    subscribers(dispatch)\r\n  }, [])\r\n\r\n  // dispatch({\r\n  //   type: '@patients/fill',\r\n  //   payload: patients\r\n  // })\r\n\r\n  // dispatch({\r\n  //   type: '@cancerOrigins/fill',\r\n  //   payload: cancerOrigins\r\n  // })\r\n\r\n  return (\r\n    <Fragment>\r\n      <ErrorBoundary>\r\n        {isLoading && <MyFancyLoader />}\r\n\r\n        <FilterByCancerOrigin />\r\n        <PatientList />\r\n      </ErrorBoundary>\r\n    </Fragment>\r\n  )\r\n}\r\n\r\nconst FilterByCancerOrigin = () => {\r\n  // Fetched data can be read from child components\r\n  const cancerOrigins = useSelector(cancerOriginSelector)\r\n  const dispatch = useDispatch()\r\n  const changeFilter = useCallback(\r\n    (e) => {\r\n      dispatch(updateFilterAction(e.target.value))\r\n    },\r\n    [],\r\n  )\r\n\r\n  return (\r\n    <select onChange={(e) => changeFilter(e)}>\r\n      <option key='all' value='all'>All</option>\r\n      {cancerOrigins.map((origin) => <option key={origin.id} value={origin.id}>{origin.id} - {origin.title}</option>)}\r\n    </select>\r\n  )\r\n}","export const updateFilterAction = (value) => ({\r\n    type: '@filter/update',\r\n    payload: value\r\n})","export const filterReducer = (state = 'all', action) => {\r\n    if (action.type === '@filter/update') {\r\n        return action.payload\r\n    }\r\n    return state\r\n}","import { combineReducers, createStore } from \"redux\";\r\nimport { cancerOrigins, patients, filter } from './reducers'\r\n\r\nexport const store = createStore(combineReducers({\r\n    patients,\r\n    cancerOrigins,\r\n    filter\r\n}), window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__())","export function patients(state = [], action) {\r\n    switch (action.type) {\r\n        case '@patients/fill':\r\n            return action.payload ? action.payload : []\r\n        default:\r\n            return state\r\n    }\r\n}","export function cancerOrigins(state = [], action) {\r\n    switch (action.type) {\r\n        case '@cancerOrigins/fill':\r\n            return action.payload ? action.payload : []\r\n        default:\r\n            return state\r\n    }\r\n}","import React from 'react'\r\nimport { Provider } from \"react-redux\";\r\nimport { Patients } from './components/Fetch';\r\nimport { store } from './store'\r\n\r\nfunction App() {\r\n  return (\r\n    <Provider store={store}>\r\n      <h1>Cancer origins and patients</h1>\r\n      <Patients />\r\n    </Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}